
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Assignment 1: GCD &#8212; Principles of programming I: Imperative computation (forever alpha) documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Practice problems" href="practice.html" />
    <link rel="prev" title="Arrays" href="arrays.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Principles of programming I: Imperative computation (forever alpha) documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p class="caption">
 <span class="caption-text">
  Contents:
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="welcome.html">
   Welcome
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction to imperative computation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="warmup.html">
   Warming up with the power function
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="reasoning.html">
   Reasoning with imperative programs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c0.html">
   More C0
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="arrays.html">
   Arrays
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Assignment 1: GCD
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="practice.html">
   Practice problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="searching.html">
   Searching
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sorting.html">
   Sorting - an information theoretic introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="binsearch.html">
   Binary search
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="avl.html">
   AVL trees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lists.html">
   Linked lists
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c.html">
   Transitioning to C
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/gcd.rst.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.rst</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#testing-the-function">
   Testing the function
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#translating-to-c0">
   Translating to C0
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#writing-the-specification-in-c0">
   Writing the specification in C0
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pre-conditions-for-gcd">
   Pre-conditions for
   <code class="docutils literal notranslate">
    <span class="pre">
     gcd
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#post-conditions-for-gcd">
   Post-conditions for
   <code class="docutils literal notranslate">
    <span class="pre">
     gcd
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examining-the-iteration">
   Examining the iteration
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pre-conditions-of-gcd-iter">
     Pre-conditions of
     <code class="docutils literal notranslate">
      <span class="pre">
       gcd_iter
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#post-conditions-of-gcd-iter">
     Post-conditions of
     <code class="docutils literal notranslate">
      <span class="pre">
       gcd_iter
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-complete-implementation">
   The complete implementation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-lcm">
   The LCM
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#things-to-be-wary-of">
   Things to be wary of
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="assignment-1-gcd">
<h1>Assignment 1: GCD<a class="headerlink" href="#assignment-1-gcd" title="Permalink to this headline">Â¶</a></h1>
<p>This section is about the first assignment regarding the GCD function.
Based on the submissions I went through, there seems to be considerable
confusion regarding the concepts involved. So in this section weâll
go through those in somewhat excruciating detail to understand the
basics well.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Spoilers ahead!</p>
</div>
<p>We started with the python function that supposedly computes the GCD
of two numbers</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</pre></div>
</div>
<p>When given any function like this, the first step is to understand
what this function is supposed to do. The next step is to understand
what it does. The final step is to codify this understanding in
contracts.</p>
<p>When writing functions on the other hand from scratch, start with a
notion of what the function is expected to do, codify it in contracts
and <strong>then</strong> implement the function.</p>
<p>The first task has been made somewhat simple for us - weâve been told
that this function is supposed to compute the GCD of two numbers.</p>
<p>Now, mathematically, the GCD of two positive integers is defined as
the largest integer that divides (i.e. that is a factor of) both the
numbers. We should capture this idea in a spec</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, weâre taking the description literally. We first identify candidate
values for the GCD, then filter out values that arenât divisors of both
given numbers, and then pick the largest of them.</p>
<p>Python is expressive enough to let you make such specifications in high
level code. Why is making such a specification useful? We can now test
the given function against it. But before that, letâs see all the other
ways in which we couldâve written this specification without loss of
generality</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start with the largest possible value and</span>
<span class="c1"># keep trying lower values until you hit a common</span>
<span class="c1"># factor. Then that will be the largest.</span>
<span class="k">def</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="n">c</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="c1"># Make a range of values from the largest candidate to the</span>
<span class="c1"># smallest (which is 1) and pick the first one of this range</span>
<span class="c1"># that is a factor of both numbers.</span>
<span class="k">def</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>


<span class="c1"># Make a list of all common factors in descending order and pick the first one.</span>
<span class="k">def</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


<span class="c1"># Make a list of all common factors and pick the largest.</span>
<span class="k">def</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>All the above versions appear obvious enough provided you know what <code class="docutils literal notranslate"><span class="pre">range</span></code>,
<code class="docutils literal notranslate"><span class="pre">max</span></code> and such things do.</p>
<div class="section" id="testing-the-function">
<h2>Testing the function<a class="headerlink" href="#testing-the-function" title="Permalink to this headline">Â¶</a></h2>
<p>Now letâs test the given <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function against this spec and see
whether it meets the spec. Paraphrasing a popular saying, âIn God we
trust. The rest better show tests.â</p>
<p>Letâs make pairs of numbers such that at least one of them is &gt; 0
(since mathematically gcd(0,0) is not defined) and then check what
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> gives us and the <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> (any of the above versions)
gives us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)]</span>
</pre></div>
</div>
<p>In the above code, weâre collecting all the pairs for which the
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does not produce the same result as our spec
function. We use <code class="docutils literal notranslate"><span class="pre">m+n&gt;0</span></code> to indicate that at least one of the two
numbers must be <code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does what it was advertised to do, we should
get an empty array in the above step since weâre looking for <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code>
combinations for which the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does not match the
<code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> function.</p>
<p>If you calculate the above list, youâll see that the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function
does not return the same value as the spec whenever <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>.
So letâs see what happens for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>. To do that, we can rewrite
the given gcd function using m alone instead of n</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">m</span>
<span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">%</span> <span class="pre">m</span></code> is zero for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, we get a result of <code class="docutils literal notranslate"><span class="pre">0</span></code> whenever
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>. Whereas we should get the answer as <code class="docutils literal notranslate"><span class="pre">m</span></code>. There are a couple
of ways we can address this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="k">return</span> <span class="n">m</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</pre></div>
</div>
<p>The latter version might be familiar to you from the first lecture.</p>
<p>Now, you were not expected to bug fix this function right at the first step,
but the hope was that by the time you got around to Q7, you wouldâve poked
around enough with the logic of this function to see its flaws.</p>
</div>
<div class="section" id="translating-to-c0">
<h2>Translating to C0<a class="headerlink" href="#translating-to-c0" title="Permalink to this headline">Â¶</a></h2>
<p>Letâs do a straight forward translation to C0.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
         <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>This translation indicates the failings of not having an accurate mental model
of the language weâre translating to and relying only on what one might call
âsurface structureâ or âsyntaxâ. If you look carefully, youâll notice that
weâve not introduced a dependency between the two update calculations, which
did not exist in the python code. The python code <code class="docutils literal notranslate"><span class="pre">m,n</span> <span class="pre">=</span> <span class="pre">m%n,n%m</span></code> calculates
the RHS first before reassigning <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> to the new values, whereas
the C0/C version above updates <code class="docutils literal notranslate"><span class="pre">m</span></code> first and tries to calculate an updated
value for <code class="docutils literal notranslate"><span class="pre">n</span></code> using the updated <code class="docutils literal notranslate"><span class="pre">m</span></code>. The way to address this is to
store away the calculations in temporary variables and then perform the
assignment.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="kt">int</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
         <span class="n">m</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
         <span class="n">n</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>Yes we havenât fixed the logical bug, but at least our translation is now
on par with the python version.</p>
</div>
<div class="section" id="writing-the-specification-in-c0">
<h2>Writing the specification in C0<a class="headerlink" href="#writing-the-specification-in-c0" title="Permalink to this headline">Â¶</a></h2>
<p>The first while-loop based formulation of <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> is more amenable
to translation to C0 than the others, since the other versions rely on
python facilities that donât exist in C0.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">gcd_spec</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="p">}</span>

     <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">candidate</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">candidate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>Note that the goal of writing the spec function is that its correctness is as
obvious as possible - i.e. makes the fewest assumptions about the properties of
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> as possible.</p>
<p>One thing to note here is that we expect the <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> to be valid only for
the condition <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> since <code class="docutils literal notranslate"><span class="pre">gcd_spec(0,0)</span></code> is not
defined and for this purpose we arenât concerned about GCD of negative numbers.</p>
</div>
<div class="section" id="pre-conditions-for-gcd">
<h2>Pre-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code><a class="headerlink" href="#pre-conditions-for-gcd" title="Permalink to this headline">Â¶</a></h2>
<p>As we saw, our <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function can only promise to produce a correct result
when <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. In particular, it cannot guarantee a
correct result for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>. Therefore our
precondition for <code class="docutils literal notranslate"><span class="pre">gcd</span></code> should read</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>â¦ or equivalently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>However, since the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function produces a value for <code class="docutils literal notranslate"><span class="pre">m+n==0</span></code> case too,
we may choose to accept that value even though it doesnât make sense
mathematically. The reason this is not a bad thing to do is that it is
reasonable to expect that someone calling <code class="docutils literal notranslate"><span class="pre">gcd</span></code> will be aware of the fact
that GCD is not defined when both numbers are 0, but might not want to add
special cases to check that. In a real program, such a condition might be
signalled by <code class="docutils literal notranslate"><span class="pre">gcd</span></code> never returning properly and instead âraising an
exceptionâ.</p>
<p>That said, since weâre using contracts here to do the checking for us, it
would be great if the checker can point out when the caller has forgotten
that GCD is undefined for <code class="docutils literal notranslate"><span class="pre">gcd(0,0)</span></code>. Therefore the full <code class="docutils literal notranslate"><span class="pre">&#64;requires</span></code>
expression above is valuable.</p>
</div>
<div class="section" id="post-conditions-for-gcd">
<h2>Post-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code><a class="headerlink" href="#post-conditions-for-gcd" title="Permalink to this headline">Â¶</a></h2>
<p>Having written <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code>, this should be easy to see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@ensures</span> \<span class="n">result</span> <span class="o">==</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="examining-the-iteration">
<h2>Examining the iteration<a class="headerlink" href="#examining-the-iteration" title="Permalink to this headline">Â¶</a></h2>
<p>Letâs look at the body of the loop we wrote for <code class="docutils literal notranslate"><span class="pre">gcd</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
</pre></div>
</div>
<p>The scope of the variables <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> (chosen to be short for
âtemporary mâ and âtemporary nâ) is limited to the inner-most pair
of braces, which is the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. So the state when entering
the loop is only <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> and the state when exiting the loop
is also <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> since <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> go out of scope.</p>
<p>Therefore the relevant state of this loop is only the two variables
<code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>From a scoring perspective, I have not penalized if you included the
temporary variables also, since I do think it is a good practice to
first account for all variables before deciding which ones are actually
relevant.</p>
<p>The python equivalent of this iteration is therefore just:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
</pre></div>
</div>
<p>since the loop can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Supposing we rewrote the python version of the iteration using temporary
variables like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">tn</span>
</pre></div>
</div>
<p>you can see that the outer loop remains the same. This is the reason
we do not consider local variables like <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> as part of the
state that is transformed by the loop.</p>
<p>That said, it isnât a fatal error to have done so. Thatâs because pretty
soon in the analysis, youâll start to see the irrelevance of the temporaries
to the correctness and safety of the function. So starting with a diligent
collection of relevant variables as part of the âstateâ is ok and youâll soon
be able to identify irrelevant variables quickly.</p>
<div class="section" id="pre-conditions-of-gcd-iter">
<h3>Pre-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code><a class="headerlink" href="#pre-conditions-of-gcd-iter" title="Permalink to this headline">Â¶</a></h3>
<p>Now, what preconditions must hold for <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> to be able to perform
its task? Looking at the operations it uses, we see that both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>
feature in the denominator of a modulus operation. Therefore neither
variable can be 0. Since we also know they cannot be negative in our
case, we can express the preconditions for <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="post-conditions-of-gcd-iter">
<h3>Post-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code><a class="headerlink" href="#post-conditions-of-gcd-iter" title="Permalink to this headline">Â¶</a></h3>
<p>If we look at <code class="docutils literal notranslate"><span class="pre">tm</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">%</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span></code>, we see that one of them does
not change value and the other one reduces. If say <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, then <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span> <span class="pre">==</span>
<span class="pre">n</span></code>. Likewise if <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span></code>, then <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">m</span></code>. In both those cases, the
following mathematical property holds</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gcd_spec</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, if the GCD can be computed for <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, it is the
same value as youâd get if you calculated the GCD of <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.
This is therefore our loop invariant.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The value of this loop invariant lies in the fact that
it can help us prove that we will get the result eventually,
since we know that at least one of the two values reduces in each
iteration. This is, however, operational reasoning.</p>
</div>
<p>Also important to see is that the loop invariant must hold <strong>irrespective</strong>
of how the loop body does its work!! This is the key to understanding
loop invariants and is also why youâre asked to write the invariants first
before writing the loop body. Having identified the invariant, we can write
it down so that <code class="docutils literal notranslate"><span class="pre">coin</span> <span class="pre">-d</span></code> can check it for us and point to any errors
in the loop body.</p>
<p>To see why this has to be the loop invariant for this algorithm, look
at the last case (for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">n</span></code>) when we exit the while loop. At that
point, one of the two values is 0 and we expect the other non-zero value
to be the GCD of the original <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>. So if this invariant did
not hold all through the loop, this condition will not be possible.</p>
<p>We also have another invariant here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This is because we cannot compute <code class="docutils literal notranslate"><span class="pre">gcd(0,0)</span></code> anywhere as it does not have
mathematical validity.</p>
<p>Now how about <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code> which is the only remaining condition to check? In
this case, we see that both <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> become 0 and our loop
invariant fails because we then try to compute <code class="docutils literal notranslate"><span class="pre">gcd_spec(0,0)</span></code>. Since we
know that <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> must hold, and this loop is not giving us that,
<strong>we conclude that there is a bug in the loop</strong>.</p>
<p>A fixed version of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> is therefore:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">m</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="k">else</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">tn</span>
</pre></div>
</div>
<p>Now, why should <code class="docutils literal notranslate"><span class="pre">gcd_spec(tm,tn)</span> <span class="pre">==</span> <span class="pre">gcd_spec(m,n)</span></code>?</p>
<p>This is because for given <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, we have <code class="docutils literal notranslate"><span class="pre">gcd_spec(m,n)</span> <span class="pre">==</span> <span class="pre">gcd_spec(n,</span> <span class="pre">m%n)</span></code>.</p>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(g\)</span> be the GCD of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. This means <span class="math notranslate nohighlight">\(m =
ga\)</span> and <span class="math notranslate nohighlight">\(n = gb\)</span> for some integers <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>.</p></li>
<li><p>If we now assume <span class="math notranslate nohighlight">\(m &gt; n\)</span>, then we have <span class="math notranslate nohighlight">\(a &gt; b\)</span> and therefore
<span class="math notranslate nohighlight">\(g\)</span> is also the GCD of <span class="math notranslate nohighlight">\(m-n\)</span> and <span class="math notranslate nohighlight">\(n\)</span> since <span class="math notranslate nohighlight">\(m-n = g(a-b)\)</span>.</p></li>
<li><p>As long as <span class="math notranslate nohighlight">\(m-n\)</span> continues to be <span class="math notranslate nohighlight">\(&gt; n\)</span>, we can keep subtracting <span class="math notranslate nohighlight">\(n\)</span>
from it. The result at the end of this process will be <span class="math notranslate nohighlight">\(m \text{mod} n\)</span>. Therefore
<span class="math notranslate nohighlight">\(\text{gcd}(m \text{mod} n,n) = \text{gcd}(m,n)\)</span> for <span class="math notranslate nohighlight">\(m &gt; n\)</span>.</p></li>
</ol>
<p>The algorithm is derived from this property of modulo division.</p>
<p>Another useful way to look at this is to rewrite the loop using recursion:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># The terminating condition for the recursion.</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span> <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>We can rewrite the above recursive form using some additional local variables
like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">tm</span> <span class="o">&gt;</span> <span class="n">tn</span><span class="p">:</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</pre></div>
</div>
<p>The above form should make clear the existence nad nature of the invariant because
it is essentially saying <code class="docutils literal notranslate"><span class="pre">gcd(m,n)</span> <span class="pre">==</span> <span class="pre">gcd(tn,tn)</span></code>.</p>
<p>Now, why canât we write everything using recursion? Nothing really stops us from
doing it except that many languages do not guarantee that they will support recursion
to arbitrary depths. Depending on the algorithm it might actually be quite feasible
to use recursion even in such languages like Python, Java and C. Other languages
like Common Lisp and Scheme support a mechanism called âtail call eliminationâ
which enables us to use recursion to express loops without a performance penalty.
If time permits, weâll visit that topic in this course.</p>
<p>For another example, below is our <code class="docutils literal notranslate"><span class="pre">pow</span></code> function expressed recursively, so you
can see the invariant clearly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where weâre expected to call <code class="docutils literal notranslate"><span class="pre">pow</span></code> as <code class="docutils literal notranslate"><span class="pre">pow(m,n,1)</span></code> to compute <code class="docutils literal notranslate"><span class="pre">m^n</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The extra argument <code class="docutils literal notranslate"><span class="pre">r</span></code> in such recursive forms is called an
âaccumulatorâ and is used to contain the result when expressing recursive
calculations using âtail recursive functionsâ. In the above <code class="docutils literal notranslate"><span class="pre">pow</span></code>
implementation, you may be able to see that the top level <code class="docutils literal notranslate"><span class="pre">pow</span></code> function
does not have anything else to do after it finishes computing the inner
<code class="docutils literal notranslate"><span class="pre">pow</span></code> call. Therefore the inner call is called the âtail callâ. Some
compilers can notice such tail calls and turn them into loops automatically,
giving us eht benefit of logical clarity without compromising efficiency.
This is just some extra info at this point for those interested.</p>
</div>
</div>
</div>
<div class="section" id="the-complete-implementation">
<h2>The complete implementation<a class="headerlink" href="#the-complete-implementation" title="Permalink to this headline">Â¶</a></h2>
<p>Putting all of the above together,</p>
<p>When written out in this form, it is easy to see that the <code class="docutils literal notranslate"><span class="pre">tm</span> <span class="pre">+</span> <span class="pre">tn</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> loop
invariant is superfluous since we already have <code class="docutils literal notranslate"><span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> prior to the loopâs
start and both can become 0 only if both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are 0 in the first
place. Anyway, weâll leave it in there as an illustration.</p>
</div>
<div class="section" id="the-lcm">
<h2>The LCM<a class="headerlink" href="#the-lcm" title="Permalink to this headline">Â¶</a></h2>
<p>Exploiting the property that <code class="docutils literal notranslate"><span class="pre">gcd(m,n)</span> <span class="pre">*</span> <span class="pre">lcm(m,n)</span> <span class="pre">==</span> <span class="pre">m*n</span></code>, we can write
an initial <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> like this</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, pay careful attention to the exact calculation specified by that expression.
These expressions we write here, though they look like theyâre the same as their
mathematical counterparts, they actually arenât since the machine has to make
particular choices about the order in which to evaluate the expression.</p>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> function is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">prod</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">prod</span> <span class="o">/</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, it should be clear that this approach can work only if the <code class="docutils literal notranslate"><span class="pre">m*n</span></code> operation
does not overflow. To avoid this, we can exploit the fact that the GCD is a common
factor for both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> and write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works since the <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">/</span> <span class="pre">gcd_spec(m,</span> <span class="pre">n)</span></code> expression is guaranteed to be an
integer without a remainder, by property of <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code>. Of course, now we are
also faced with the constraint that the LCM itself should not be so large as to
not fit in a 32-bit signed integer. However, that is a lost cause for us,
because if it was indeed so large that the result wouldnât fit in 32 bits, we
canât represent it in our system using an <code class="docutils literal notranslate"><span class="pre">int</span></code> anyway and therefore have to
resort to other approaches.</p>
<p>Therefore our <code class="docutils literal notranslate"><span class="pre">lcm</span></code> implementation can closely follow the spec:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">lcm</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
<span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">//</span><span class="nd">@ensures</span> \<span class="n">result</span> <span class="o">==</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, we can resort to an iterative form for <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> where
we assume that <code class="docutils literal notranslate"><span class="pre">m*n</span></code> is within <code class="docutils literal notranslate"><span class="pre">int</span></code> limits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="p">}</span>
    <span class="nb">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">%</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, you donât want the <code class="docutils literal notranslate"><span class="pre">lcm</span></code> implementation to closely follow
the spec. Note here that since our loop condition is <code class="docutils literal notranslate"><span class="pre">candidate</span> <span class="pre">&lt;</span> <span class="pre">limit</span></code>,
weâre guaranteed that <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> holds within the loop and therefore
the modulo operationsâ preconditions are met.</p>
</div>
<div class="section" id="things-to-be-wary-of">
<h2>Things to be wary of<a class="headerlink" href="#things-to-be-wary-of" title="Permalink to this headline">Â¶</a></h2>
<p>Logical expressions in C and python (and in most languages) are evaluated
using an approach called âshort circuit evaluationâ that can causes different
behaviour than what one would expect mathematically. This is done for efficiency
by avoiding unnecessary computation.</p>
<p>If you have a logical condition expressed as a conjunction of boolean
expressions using âlogical andâ like â <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;&amp;</span> <span class="pre">B</span> <span class="pre">&amp;&amp;</span> <span class="pre">C</span> <span class="pre">&amp;&amp;</span> <span class="pre">..</span> <span class="pre">&amp;&amp;</span> <span class="pre">Z</span></code>,
then if you consider it mathematically, it is easy to see that if any one of
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, â¦ , <code class="docutils literal notranslate"><span class="pre">Z</span></code> happen to be <code class="docutils literal notranslate"><span class="pre">false</span></code>, then the whole expression
becomes <code class="docutils literal notranslate"><span class="pre">false</span></code> too. Therefore, when checking each component of this
compound expression in sequence, the moment you encounter a <code class="docutils literal notranslate"><span class="pre">false</span></code> result,
you can stop checking the other parts and mark the expressionâs result as <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>From a mathematical perspective, it does not matter what order we present these
logically anded parts, the result is the same, but from a computational perspective
it can matter depending on the situation.</p>
<p>Consider the expression <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span></code>. Letâs say that the array
<code class="docutils literal notranslate"><span class="pre">a</span></code> is of length <code class="docutils literal notranslate"><span class="pre">10</span></code>. Mathematically, the <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span></code> can be expected to
restrict the other condition. However, in a program, the first expression will
be evaluated without checking whether <code class="docutils literal notranslate"><span class="pre">i</span></code> is a valid index into <code class="docutils literal notranslate"><span class="pre">a</span></code> and can
therefore cause an âarray index out of boundsâ error. On the other hand, if the
expression were written as <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span> <span class="pre">&amp;&amp;</span> <span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></code>, the second expression
will be evaluated only if the first succeeds. Thus, the first expression serves
as a âguardâ for the second expression.</p>
<p>A similar âshort circuitingâ behaviour also happens for âlogical orâ, except that
in that case, if any component expression becomes <code class="docutils literal notranslate"><span class="pre">true</span></code>, the whole expression
can be considered <code class="docutils literal notranslate"><span class="pre">true</span></code> without examining any of the other sub-expressions.</p>
</div>
</div>


              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="arrays.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Arrays</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="practice.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Practice problems</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Srikumar K. S.<br/>
        
            &copy; Copyright 2021, Srikumar K. S..<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>