
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Assignment 1: GCD &#8212; Principles of programming I: Imperative computation (forever alpha) documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=f81aabf2"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'gcd';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Practice problems" href="practice.html" />
    <link rel="prev" title="Arrays" href="arrays.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
  
    <p class="title logo__title">Principles of programming I: Imperative computation (forever alpha) documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="welcome.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to imperative computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="warmup.html">Warming up with the power function</a></li>
<li class="toctree-l1"><a class="reference internal" href="reasoning.html">Reasoning with imperative programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="c0.html">More C0</a></li>
<li class="toctree-l1"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Assignment 1: GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="practice.html">Practice problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="sorting.html">Sorting - an information theoretic introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="binsearch.html">Binary search</a></li>
<li class="toctree-l1"><a class="reference internal" href="avl.html">AVL trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="lists.html">Linked lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="c.html">Transitioning to C</a></li>
<li class="toctree-l1"><a class="reference internal" href="dict.html">Dictionaries and associated data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="bitset.html">Bit sets</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/gcd.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Assignment 1: GCD</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-the-function">Testing the function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translating-to-c0">Translating to C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#writing-the-specification-in-c0">Writing the specification in C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pre-conditions-for-gcd">Pre-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#post-conditions-for-gcd">Post-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#examining-the-iteration">Examining the iteration</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pre-conditions-of-gcd-iter">Pre-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#post-conditions-of-gcd-iter">Post-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-complete-implementation">The complete implementation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-lcm">The LCM</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#things-to-be-wary-of">Things to be wary of</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="assignment-1-gcd">
<h1>Assignment 1: GCD<a class="headerlink" href="#assignment-1-gcd" title="Link to this heading">#</a></h1>
<p>This section is about the first assignment regarding the GCD function.
Based on the submissions I went through, there seems to be considerable
confusion regarding the concepts involved. So in this section we’ll
go through those in somewhat excruciating detail to understand the
basics well.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Spoilers ahead!</p>
</div>
<p>We started with the python function that supposedly computes the GCD
of two numbers</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</pre></div>
</div>
<p>When given any function like this, the first step is to understand
what this function is supposed to do. The next step is to understand
what it does. The final step is to codify this understanding in
contracts.</p>
<p>When writing functions on the other hand from scratch, start with a
notion of what the function is expected to do, codify it in contracts
and <strong>then</strong> implement the function.</p>
<p>The first task has been made somewhat simple for us - we’ve been told
that this function is supposed to compute the GCD of two numbers.</p>
<p>Now, mathematically, the GCD of two positive integers is defined as
the largest integer that divides (i.e. that is a factor of) both the
numbers. We should capture this idea in a spec</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we’re taking the description literally. We first identify candidate
values for the GCD, then filter out values that aren’t divisors of both
given numbers, and then pick the largest of them.</p>
<p>Python is expressive enough to let you make such specifications in high
level code. Why is making such a specification useful? We can now test
the given function against it. But before that, let’s see all the other
ways in which we could’ve written this specification without loss of
generality</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start with the largest possible value and</span>
<span class="c1"># keep trying lower values until you hit a common</span>
<span class="c1"># factor. Then that will be the largest.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="n">c</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">c</span>

<span class="c1"># Make a range of values from the largest candidate to the</span>
<span class="c1"># smallest (which is 1) and pick the first one of this range</span>
<span class="c1"># that is a factor of both numbers.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>


<span class="c1"># Make a list of all common factors in descending order and pick the first one.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


<span class="c1"># Make a list of all common factors and pick the largest.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>All the above versions appear obvious enough provided you know what <code class="docutils literal notranslate"><span class="pre">range</span></code>,
<code class="docutils literal notranslate"><span class="pre">max</span></code> and such things do.</p>
<section id="testing-the-function">
<h2>Testing the function<a class="headerlink" href="#testing-the-function" title="Link to this heading">#</a></h2>
<p>Now let’s test the given <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function against this spec and see
whether it meets the spec. Paraphrasing a popular saying, “In God we
trust. The rest better show tests.”</p>
<p>Let’s make pairs of numbers such that at least one of them is &gt; 0
(since mathematically gcd(0,0) is not defined) and then check what
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> gives us and the <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> (any of the above versions)
gives us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)]</span>
</pre></div>
</div>
<p>In the above code, we’re collecting all the pairs for which the
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does not produce the same result as our spec
function. We use <code class="docutils literal notranslate"><span class="pre">m+n&gt;0</span></code> to indicate that at least one of the two
numbers must be <code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does what it was advertised to do, we should
get an empty array in the above step since we’re looking for <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code>
combinations for which the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function does not match the
<code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> function.</p>
<p>If you calculate the above list, you’ll see that the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function
does not return the same value as the spec whenever <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>.
So let’s see what happens for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>. To do that, we can rewrite
the given gcd function using m alone instead of n</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">m</span>
<span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">m</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">%</span> <span class="pre">m</span></code> is zero for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, we get a result of <code class="docutils literal notranslate"><span class="pre">0</span></code> whenever
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code>. Whereas we should get the answer as <code class="docutils literal notranslate"><span class="pre">m</span></code>. There are a couple
of ways we can address this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="k">return</span> <span class="n">m</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

<span class="k">def</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>
</pre></div>
</div>
<p>The latter version might be familiar to you from the first lecture.</p>
<p>Now, you were not expected to bug fix this function right at the first step,
but the hope was that by the time you got around to Q7, you would’ve poked
around enough with the logic of this function to see its flaws.</p>
</section>
<section id="translating-to-c0">
<h2>Translating to C0<a class="headerlink" href="#translating-to-c0" title="Link to this heading">#</a></h2>
<p>Let’s do a straight forward translation to C0.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">         </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>This translation indicates the failings of not having an accurate mental model
of the language we’re translating to and relying only on what one might call
“surface structure” or “syntax”. If you look carefully, you’ll notice that
we’ve not introduced a dependency between the two update calculations, which
did not exist in the python code. The python code <code class="docutils literal notranslate"><span class="pre">m,n</span> <span class="pre">=</span> <span class="pre">m%n,n%m</span></code> calculates
the RHS first before reassigning <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> to the new values, whereas
the C0/C version above updates <code class="docutils literal notranslate"><span class="pre">m</span></code> first and tries to calculate an updated
value for <code class="docutils literal notranslate"><span class="pre">n</span></code> using the updated <code class="docutils literal notranslate"><span class="pre">m</span></code>. The way to address this is to
store away the calculations in temporary variables and then perform the
assignment.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">         </span><span class="kt">int</span><span class="w"> </span><span class="n">tn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">         </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tm</span><span class="p">;</span>
<span class="w">         </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tn</span><span class="p">;</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Yes we haven’t fixed the logical bug, but at least our translation is now
on par with the python version.</p>
</section>
<section id="writing-the-specification-in-c0">
<h2>Writing the specification in C0<a class="headerlink" href="#writing-the-specification-in-c0" title="Link to this heading">#</a></h2>
<p>The first while-loop based formulation of <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> is more amenable
to translation to C0 than the others, since the other versions rely on
python facilities that don’t exist in C0.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">gcd_spec</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">gcd_spec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">     </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">candidate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="k">return</span><span class="w"> </span><span class="n">candidate</span><span class="p">;</span>
<span class="w">         </span><span class="p">}</span>
<span class="w">         </span><span class="n">candidate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">     </span><span class="p">}</span>

<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">candidate</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Note that the goal of writing the spec function is that its correctness is as
obvious as possible - i.e. makes the fewest assumptions about the properties of
<code class="docutils literal notranslate"><span class="pre">gcd</span></code> as possible.</p>
<p>One thing to note here is that we expect the <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code> to be valid only for
the condition <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> since <code class="docutils literal notranslate"><span class="pre">gcd_spec(0,0)</span></code> is not
defined and for this purpose we aren’t concerned about GCD of negative numbers.</p>
</section>
<section id="pre-conditions-for-gcd">
<h2>Pre-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code><a class="headerlink" href="#pre-conditions-for-gcd" title="Link to this heading">#</a></h2>
<p>As we saw, our <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function can only promise to produce a correct result
when <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. In particular, it cannot guarantee a
correct result for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>. Therefore our
precondition for <code class="docutils literal notranslate"><span class="pre">gcd</span></code> should read</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>… or equivalently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>However, since the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function produces a value for <code class="docutils literal notranslate"><span class="pre">m+n==0</span></code> case too,
we may choose to accept that value even though it doesn’t make sense
mathematically. The reason this is not a bad thing to do is that it is
reasonable to expect that someone calling <code class="docutils literal notranslate"><span class="pre">gcd</span></code> will be aware of the fact
that GCD is not defined when both numbers are 0, but might not want to add
special cases to check that. In a real program, such a condition might be
signalled by <code class="docutils literal notranslate"><span class="pre">gcd</span></code> never returning properly and instead “raising an
exception”.</p>
<p>That said, since we’re using contracts here to do the checking for us, it
would be great if the checker can point out when the caller has forgotten
that GCD is undefined for <code class="docutils literal notranslate"><span class="pre">gcd(0,0)</span></code>. Therefore the full <code class="docutils literal notranslate"><span class="pre">&#64;requires</span></code>
expression above is valuable.</p>
</section>
<section id="post-conditions-for-gcd">
<h2>Post-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code><a class="headerlink" href="#post-conditions-for-gcd" title="Link to this heading">#</a></h2>
<p>Having written <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code>, this should be easy to see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="nd">@ensures</span> \<span class="n">result</span> <span class="o">==</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="examining-the-iteration">
<h2>Examining the iteration<a class="headerlink" href="#examining-the-iteration" title="Link to this heading">#</a></h2>
<p>Let’s look at the body of the loop we wrote for <code class="docutils literal notranslate"><span class="pre">gcd</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
</pre></div>
</div>
<p>The scope of the variables <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> (chosen to be short for
“temporary m” and “temporary n”) is limited to the inner-most pair
of braces, which is the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop. So the state when entering
the loop is only <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> and the state when exiting the loop
is also <code class="docutils literal notranslate"><span class="pre">(m,n)</span></code> since <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> go out of scope.</p>
<p>Therefore the relevant state of this loop is only the two variables
<code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>From a scoring perspective, I have not penalized if you included the
temporary variables also, since I do think it is a good practice to
first account for all variables before deciding which ones are actually
relevant.</p>
<p>The python equivalent of this iteration is therefore just:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
</pre></div>
</div>
<p>since the loop can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Supposing we rewrote the python version of the iteration using temporary
variables like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">tn</span>
</pre></div>
</div>
<p>you can see that the outer loop remains the same. This is the reason
we do not consider local variables like <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> as part of the
state that is transformed by the loop.</p>
<p>That said, it isn’t a fatal error to have done so. That’s because pretty
soon in the analysis, you’ll start to see the irrelevance of the temporaries
to the correctness and safety of the function. So starting with a diligent
collection of relevant variables as part of the “state” is ok and you’ll soon
be able to identify irrelevant variables quickly.</p>
<section id="pre-conditions-of-gcd-iter">
<h3>Pre-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code><a class="headerlink" href="#pre-conditions-of-gcd-iter" title="Link to this heading">#</a></h3>
<p>Now, what preconditions must hold for <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> to be able to perform
its task? Looking at the operations it uses, we see that both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>
feature in the denominator of a modulus operation. Therefore neither
variable can be 0. Since we also know they cannot be negative in our
case, we can express the preconditions for <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="post-conditions-of-gcd-iter">
<h3>Post-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code><a class="headerlink" href="#post-conditions-of-gcd-iter" title="Link to this heading">#</a></h3>
<p>If we look at <code class="docutils literal notranslate"><span class="pre">tm</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">%</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span></code>, we see that one of them does
not change value and the other one reduces. If say <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, then <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span> <span class="pre">==</span>
<span class="pre">n</span></code>. Likewise if <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;</span> <span class="pre">n</span></code>, then <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">%</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">m</span></code>. In both those cases, the
following mathematical property holds</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gcd_spec</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span> <span class="o">==</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, if the GCD can be computed for <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, it is the
same value as you’d get if you calculated the GCD of <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code>.
This is therefore our loop invariant.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The value of this loop invariant lies in the fact that
it can help us prove that we will get the result eventually,
since we know that at least one of the two values reduces in each
iteration. This is, however, operational reasoning.</p>
</div>
<p>Also important to see is that the loop invariant must hold <strong>irrespective</strong>
of how the loop body does its work!! This is the key to understanding
loop invariants and is also why you’re asked to write the invariants first
before writing the loop body. Having identified the invariant, we can write
it down so that <code class="docutils literal notranslate"><span class="pre">coin</span> <span class="pre">-d</span></code> can check it for us and point to any errors
in the loop body.</p>
<p>To see why this has to be the loop invariant for this algorithm, look
at the last case (for <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">!=</span> <span class="pre">n</span></code>) when we exit the while loop. At that
point, one of the two values is 0 and we expect the other non-zero value
to be the GCD of the original <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>. So if this invariant did
not hold all through the loop, this condition will not be possible.</p>
<p>We also have another invariant here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>This is because we cannot compute <code class="docutils literal notranslate"><span class="pre">gcd(0,0)</span></code> anywhere as it does not have
mathematical validity.</p>
<p>Now how about <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">n</span></code> which is the only remaining condition to check? In
this case, we see that both <code class="docutils literal notranslate"><span class="pre">tm</span></code> and <code class="docutils literal notranslate"><span class="pre">tn</span></code> become 0 and our loop
invariant fails because we then try to compute <code class="docutils literal notranslate"><span class="pre">gcd_spec(0,0)</span></code>. Since we
know that <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> must hold, and this loop is not giving us that,
<strong>we conclude that there is a bug in the loop</strong>.</p>
<p>A fixed version of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code> is therefore:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd_iter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">m</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="k">else</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">tm</span><span class="p">,</span> <span class="n">tn</span>
</pre></div>
</div>
<p>Now, why should <code class="docutils literal notranslate"><span class="pre">gcd_spec(tm,tn)</span> <span class="pre">==</span> <span class="pre">gcd_spec(m,n)</span></code>?</p>
<p>This is because for given <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>, we have <code class="docutils literal notranslate"><span class="pre">gcd_spec(m,n)</span> <span class="pre">==</span> <span class="pre">gcd_spec(n,</span> <span class="pre">m%n)</span></code>.</p>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(g\)</span> be the GCD of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. This means <span class="math notranslate nohighlight">\(m =
ga\)</span> and <span class="math notranslate nohighlight">\(n = gb\)</span> for some integers <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>.</p></li>
<li><p>If we now assume <span class="math notranslate nohighlight">\(m &gt; n\)</span>, then we have <span class="math notranslate nohighlight">\(a &gt; b\)</span> and therefore
<span class="math notranslate nohighlight">\(g\)</span> is also the GCD of <span class="math notranslate nohighlight">\(m-n\)</span> and <span class="math notranslate nohighlight">\(n\)</span> since <span class="math notranslate nohighlight">\(m-n = g(a-b)\)</span>.</p></li>
<li><p>As long as <span class="math notranslate nohighlight">\(m-n\)</span> continues to be <span class="math notranslate nohighlight">\(&gt; n\)</span>, we can keep subtracting <span class="math notranslate nohighlight">\(n\)</span>
from it. The result at the end of this process will be <span class="math notranslate nohighlight">\(m \text{mod} n\)</span>. Therefore
<span class="math notranslate nohighlight">\(\text{gcd}(m \text{mod} n,n) = \text{gcd}(m,n)\)</span> for <span class="math notranslate nohighlight">\(m &gt; n\)</span>.</p></li>
</ol>
<p>The algorithm is derived from this property of modulo division.</p>
<p>Another useful way to look at this is to rewrite the loop using recursion:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c1"># The terminating condition for the recursion.</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span> <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>We can rewrite the above recursive form using some additional local variables
like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span>

    <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">tm</span> <span class="o">&gt;</span> <span class="n">tn</span><span class="p">:</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</pre></div>
</div>
<p>The above form should make clear the existence nad nature of the invariant because
it is essentially saying <code class="docutils literal notranslate"><span class="pre">gcd(m,n)</span> <span class="pre">==</span> <span class="pre">gcd(tn,tn)</span></code>.</p>
<p>Now, why can’t we write everything using recursion? Nothing really stops us from
doing it except that many languages do not guarantee that they will support recursion
to arbitrary depths. Depending on the algorithm it might actually be quite feasible
to use recursion even in such languages like Python, Java and C. Other languages
like Common Lisp and Scheme support a mechanism called “tail call elimination”
which enables us to use recursion to express loops without a performance penalty.
If time permits, we’ll visit that topic in this course.</p>
<p>For another example, below is our <code class="docutils literal notranslate"><span class="pre">pow</span></code> function expressed recursively, so you
can see the invariant clearly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where we’re expected to call <code class="docutils literal notranslate"><span class="pre">pow</span></code> as <code class="docutils literal notranslate"><span class="pre">pow(m,n,1)</span></code> to compute <code class="docutils literal notranslate"><span class="pre">m^n</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The extra argument <code class="docutils literal notranslate"><span class="pre">r</span></code> in such recursive forms is called an
“accumulator” and is used to contain the result when expressing recursive
calculations using “tail recursive functions”. In the above <code class="docutils literal notranslate"><span class="pre">pow</span></code>
implementation, you may be able to see that the top level <code class="docutils literal notranslate"><span class="pre">pow</span></code> function
does not have anything else to do after it finishes computing the inner
<code class="docutils literal notranslate"><span class="pre">pow</span></code> call. Therefore the inner call is called the “tail call”. Some
compilers can notice such tail calls and turn them into loops automatically,
giving us eht benefit of logical clarity without compromising efficiency.
This is just some extra info at this point for those interested.</p>
</div>
</section>
</section>
<section id="the-complete-implementation">
<h2>The complete implementation<a class="headerlink" href="#the-complete-implementation" title="Link to this heading">#</a></h2>
<p>Putting all of the above together,</p>
<p>When written out in this form, it is easy to see that the <code class="docutils literal notranslate"><span class="pre">tm</span> <span class="pre">+</span> <span class="pre">tn</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> loop
invariant is superfluous since we already have <code class="docutils literal notranslate"><span class="pre">m+n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> prior to the loop’s
start and both can become 0 only if both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are 0 in the first
place. Anyway, we’ll leave it in there as an illustration.</p>
</section>
<section id="the-lcm">
<h2>The LCM<a class="headerlink" href="#the-lcm" title="Link to this heading">#</a></h2>
<p>Exploiting the property that <code class="docutils literal notranslate"><span class="pre">gcd(m,n)</span> <span class="pre">*</span> <span class="pre">lcm(m,n)</span> <span class="pre">==</span> <span class="pre">m*n</span></code>, we can write
an initial <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> like this</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, pay careful attention to the exact calculation specified by that expression.
These expressions we write here, though they look like they’re the same as their
mathematical counterparts, they actually aren’t since the machine has to make
particular choices about the order in which to evaluate the expression.</p>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> function is equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">prod</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">prod</span> <span class="o">/</span> <span class="n">g</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, it should be clear that this approach can work only if the <code class="docutils literal notranslate"><span class="pre">m*n</span></code> operation
does not overflow. To avoid this, we can exploit the fact that the GCD is a common
factor for both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> and write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This works since the <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">/</span> <span class="pre">gcd_spec(m,</span> <span class="pre">n)</span></code> expression is guaranteed to be an
integer without a remainder, by property of <code class="docutils literal notranslate"><span class="pre">gcd_spec</span></code>. Of course, now we are
also faced with the constraint that the LCM itself should not be so large as to
not fit in a 32-bit signed integer. However, that is a lost cause for us,
because if it was indeed so large that the result wouldn’t fit in 32 bits, we
can’t represent it in our system using an <code class="docutils literal notranslate"><span class="pre">int</span></code> anyway and therefore have to
resort to other approaches.</p>
<p>Therefore our <code class="docutils literal notranslate"><span class="pre">lcm</span></code> implementation can closely follow the spec:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">lcm</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span>
<span class="o">//</span><span class="nd">@requires</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">//</span><span class="nd">@ensures</span> \<span class="n">result</span> <span class="o">==</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Alternatively, we can resort to an iterative form for <code class="docutils literal notranslate"><span class="pre">lcm_spec</span></code> where
we assume that <code class="docutils literal notranslate"><span class="pre">m*n</span></code> is within <code class="docutils literal notranslate"><span class="pre">int</span></code> limits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="nb">int</span> <span class="n">m</span><span class="p">,</span> <span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lcm_spec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="p">}</span>
    <span class="nb">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">%</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidate</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, you don’t want the <code class="docutils literal notranslate"><span class="pre">lcm</span></code> implementation to closely follow
the spec. Note here that since our loop condition is <code class="docutils literal notranslate"><span class="pre">candidate</span> <span class="pre">&lt;</span> <span class="pre">limit</span></code>,
we’re guaranteed that <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> holds within the loop and therefore
the modulo operations’ preconditions are met.</p>
</section>
<section id="things-to-be-wary-of">
<h2>Things to be wary of<a class="headerlink" href="#things-to-be-wary-of" title="Link to this heading">#</a></h2>
<p>Logical expressions in C and python (and in most languages) are evaluated
using an approach called “short circuit evaluation” that can causes different
behaviour than what one would expect mathematically. This is done for efficiency
by avoiding unnecessary computation.</p>
<p>If you have a logical condition expressed as a conjunction of boolean
expressions using “logical and” like – <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;&amp;</span> <span class="pre">B</span> <span class="pre">&amp;&amp;</span> <span class="pre">C</span> <span class="pre">&amp;&amp;</span> <span class="pre">..</span> <span class="pre">&amp;&amp;</span> <span class="pre">Z</span></code>,
then if you consider it mathematically, it is easy to see that if any one of
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, … , <code class="docutils literal notranslate"><span class="pre">Z</span></code> happen to be <code class="docutils literal notranslate"><span class="pre">false</span></code>, then the whole expression
becomes <code class="docutils literal notranslate"><span class="pre">false</span></code> too. Therefore, when checking each component of this
compound expression in sequence, the moment you encounter a <code class="docutils literal notranslate"><span class="pre">false</span></code> result,
you can stop checking the other parts and mark the expression’s result as <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>From a mathematical perspective, it does not matter what order we present these
logically anded parts, the result is the same, but from a computational perspective
it can matter depending on the situation.</p>
<p>Consider the expression <code class="docutils literal notranslate"><span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span></code>. Let’s say that the array
<code class="docutils literal notranslate"><span class="pre">a</span></code> is of length <code class="docutils literal notranslate"><span class="pre">10</span></code>. Mathematically, the <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span></code> can be expected to
restrict the other condition. However, in a program, the first expression will
be evaluated without checking whether <code class="docutils literal notranslate"><span class="pre">i</span></code> is a valid index into <code class="docutils literal notranslate"><span class="pre">a</span></code> and can
therefore cause an “array index out of bounds” error. On the other hand, if the
expression were written as <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10</span> <span class="pre">&amp;&amp;</span> <span class="pre">a[i]</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></code>, the second expression
will be evaluated only if the first succeeds. Thus, the first expression serves
as a “guard” for the second expression.</p>
<p>A similar “short circuiting” behaviour also happens for “logical or”, except that
in that case, if any component expression becomes <code class="docutils literal notranslate"><span class="pre">true</span></code>, the whole expression
can be considered <code class="docutils literal notranslate"><span class="pre">true</span></code> without examining any of the other sub-expressions.</p>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="arrays.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Arrays</p>
      </div>
    </a>
    <a class="right-next"
       href="practice.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Practice problems</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-the-function">Testing the function</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translating-to-c0">Translating to C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#writing-the-specification-in-c0">Writing the specification in C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pre-conditions-for-gcd">Pre-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#post-conditions-for-gcd">Post-conditions for <code class="docutils literal notranslate"><span class="pre">gcd</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#examining-the-iteration">Examining the iteration</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pre-conditions-of-gcd-iter">Pre-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#post-conditions-of-gcd-iter">Post-conditions of <code class="docutils literal notranslate"><span class="pre">gcd_iter</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-complete-implementation">The complete implementation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-lcm">The LCM</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#things-to-be-wary-of">Things to be wary of</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Srikumar K. S.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021, Srikumar K. S..
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>