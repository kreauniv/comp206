
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Transitioning to C &#8212; Principles of programming I: Imperative computation (forever alpha) documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=f81aabf2"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'c';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Dictionaries and associated data structures" href="dict.html" />
    <link rel="prev" title="Linked lists" href="lists.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
  
    <p class="title logo__title">Principles of programming I: Imperative computation (forever alpha) documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="welcome.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to imperative computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="warmup.html">Warming up with the power function</a></li>
<li class="toctree-l1"><a class="reference internal" href="reasoning.html">Reasoning with imperative programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="c0.html">More C0</a></li>
<li class="toctree-l1"><a class="reference internal" href="arrays.html">Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="gcd.html">Assignment 1: GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="practice.html">Practice problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="searching.html">Searching</a></li>
<li class="toctree-l1"><a class="reference internal" href="sorting.html">Sorting - an information theoretic introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="binsearch.html">Binary search</a></li>
<li class="toctree-l1"><a class="reference internal" href="avl.html">AVL trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="lists.html">Linked lists</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Transitioning to C</a></li>
<li class="toctree-l1"><a class="reference internal" href="dict.html">Dictionaries and associated data structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="bitset.html">Bit sets</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/c.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Transitioning to C</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-c-memory-model">The C memory model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-c-stack">The C stack</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#differences-from-c0">Differences from C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#casting">Casting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-pointers">Function pointers</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="transitioning-to-c">
<h1>Transitioning to C<a class="headerlink" href="#transitioning-to-c" title="Link to this heading">#</a></h1>
<p>Henceforth, we’ll be using the C programming language instead of C0.  C is one
of the most widely used languages for writing system software for large and
small (i.e. “embedded”) systems. Examples include the Linux kernel itself which
has over 25million lines of C code today. The language specification that we’ll
be using for this course is called <a class="reference external" href="https://en.wikipedia.org/wiki/C99">C99</a>.
The reason for this popularity is several fold -</p>
<ol class="arabic simple">
<li><p>C gives you very low level control of system resources like memory, which is
important in constrained systems. The early systems for which the C language
itself was developed would look extremely constrained from today’s perspective.</p></li>
<li><p>With the long history that C has (it was born in 1972), C compilers have gotten
extremely good at producing highly optimized code, which again is beneficial
to all systems large and small.</p></li>
</ol>
<p>The downside of the language is that its strength of giving the programmer a
lot of control over system resources can itself be a problem when developing
application software, since the author is forced to deal with these resources
in every circumstance. Derived languages like “C++” and “Objective-C” add
features that make routine record keeping of resources much more manageable and
less error prone.</p>
<p>That said, it is a great language to get to grips with the machine model that
we all use today - the model where a processor runs a loop of the form -</p>
<ol class="arabic simple">
<li><p>(implicit) Fetch instruction - which can tell the processor to do one of …</p></li>
<li><p>Fetch data from memory into registers</p></li>
<li><p>Compute result</p></li>
<li><p>Store result from registers into memory</p></li>
</ol>
<p>The above is a simplified picture and modern “super scalar” processors are far
more complicated, but that deserves a whole course on its own and we’ll live
with the above sketch for the purpose of this course.</p>
<section id="the-c-memory-model">
<h2>The C memory model<a class="headerlink" href="#the-c-memory-model" title="Link to this heading">#</a></h2>
<p>When we began this course, we looked at the “spreadsheet” model of memory and
how we can trace and understand the state of a program. That’s not far from the
truth. The computer’s addressable memory is like an array of single bytes whose
indices serve as their “address”. The “RAM” – random access memory – when
given an address, can give us the byte stored at that address or store a given
byte at an address. On systems today, our programs get such a virtual array
that’s about 4GB in size on 32-bit machines and 16billion GB in size on 64-bit
machines.  Of course we don’t have that much physical memory, so the kernel
uses storage like hard disks or SSDs to extend the memory available to our
programs without us having to think about it. It is <strong>as though</strong> the RAM is
modeled by the following functions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uint8_t</span> <span class="n">ram_load</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">address</span><span class="p">);</span>
<span class="n">void</span> <span class="n">ram_store</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="n">byte</span><span class="p">);</span>
</pre></div>
</div>
<p>Since the round trip to the RAM and back taken time relative to how fast our
processors can compute today, this interface is extended to fetch blocks of
memory at a time, so in reality it is more like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">block_t</span> <span class="n">ram_load_block</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">address</span><span class="p">);</span>
<span class="n">void</span> <span class="n">ram_store</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">address</span><span class="p">,</span> <span class="n">block_t</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>where we’ve used the name <code class="docutils literal notranslate"><span class="pre">block_t</span></code> to stand for the block. (i.e. it is not a
real data type in C.)</p>
</section>
<section id="the-c-stack">
<h2>The C stack<a class="headerlink" href="#the-c-stack" title="Link to this heading">#</a></h2>
<p>In addition to the main memory bulk, the C language also provides a “stack”
that is tied to scoped variables in the language.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The scope of a variable in C is determined by the inner most pair
of braces <code class="docutils literal notranslate"><span class="pre">{}</span></code> that enclose the definition of the variable.</p>
</div>
<p>Consider the following example code -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">accumulate</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Your program will need some memory to store the variables <code class="docutils literal notranslate"><span class="pre">val</span></code> (4-bytes),
<code class="docutils literal notranslate"><span class="pre">i</span></code> (4-bytes) and <code class="docutils literal notranslate"><span class="pre">tmp</span></code> (4-bytes) and also for the arguments to your
function <code class="docutils literal notranslate"><span class="pre">N</span></code> (4-bytes), <code class="docutils literal notranslate"><span class="pre">in</span></code> (8-bytes) and <code class="docutils literal notranslate"><span class="pre">out</span></code> (8-bytes). Since <code class="docutils literal notranslate"><span class="pre">in</span></code>
and <code class="docutils literal notranslate"><span class="pre">out</span></code> are pointer types, they usually are stored as 64-bit address values.</p>
<p>The storage for these variables is allocated and managed by the compiler
automatically using a “stack” structure. A variable is given some memory
on the stack only while the code within its immediate scope is executing.
So a variable is said to be “visible” only within its scope. Once a scope
is exited, the compiler may release the storage needed for the variable.</p>
<p>In the above example, the <code class="docutils literal notranslate"><span class="pre">tmp</span></code> variable is local to the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop
and is not available at the point where we’re doing <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">val;</span></code>.
However, the variables <code class="docutils literal notranslate"><span class="pre">val</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code> and so on are available within
the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop as its scope is contained in the scope of those variables.</p>
<p>Why is this called a “stack”? You can think of an open brace <code class="docutils literal notranslate"><span class="pre">{</span></code> as an
instruction to “push new variables on to the stack” and the matching <code class="docutils literal notranslate"><span class="pre">}</span></code> as
an instruction to pop all the variables up to the matching <code class="docutils literal notranslate"><span class="pre">{</span></code> from the
stack. So the stack gets deeper the more nested scopes there are (including
function calls which add their own scope) and when these scopes are exited, the
stack becomes shallower again.  This is why if your function is recursive and
makes too many recursive calls, you may run out of stack space and your program
may crash with a “stack overflow” error.</p>
<p>The stack is not very visible in C0 since you can only work with it via the
scopes. In C though, you can take the address of variables allocated on the
stack and pass them around .. while making sure you don’t use them after the
variable goes out of scope .. which means the stack is very much visible
to the programmer and the program.</p>
</section>
<section id="differences-from-c0">
<h2>Differences from C0<a class="headerlink" href="#differences-from-c0" title="Link to this heading">#</a></h2>
<p>For the most part, C0 is a subset of C, so if you write C0 code for your
functions, you’ll be writing valid C code. The difference will be in the
functions available to you in the two languages. C offers more to the
adventurous though. Below we consider the language differences from several
perspectives.</p>
<div class="pst-scrollable-table-container"><table class="table" id="id2">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">C0 versus C - pragmatics</span><a class="headerlink" href="#id2" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Task</strong></p></th>
<th class="head"><p><strong>For C0</strong></p></th>
<th class="head"><p><strong>For C</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Compile a program</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cc0</span> <span class="pre">program.c0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">program.c</span></code> or <code class="docutils literal notranslate"><span class="pre">tcc</span> <span class="pre">program.c</span></code> or <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">program.c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Run compiled program</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./a.out</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">./a.out</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Compile with contract checks/debugging enabled.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cc0</span> <span class="pre">-d</span> <span class="pre">program.c0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-d</span> <span class="pre">program.c</span></code> (same for others)</p></td>
</tr>
<tr class="row-odd"><td><p>Compile with optimizations</p></td>
<td><p>Nothing particular</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-O3</span> <span class="pre">program.c</span></code> - turns on maximum “level 3” optimizations.</p></td>
</tr>
<tr class="row-even"><td><p>Use standard libraries</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#use</span> <span class="pre">&lt;conio.h&gt;</span></code> etc. Must occur first in source file.</p></td>
<td><p>Include the library’s headers. Common ones given below.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span>
</pre></div>
</div>
<p>They can technically occur anywhere, since <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdio.h&gt;</span></code> just
means “copy paste contents of stdio.h into my code at this point”,
however they’re usually placed at top of source file.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Contracts</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;requires</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;ensures</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;assert</span></code></p></td>
<td><p>Not supported in general, but if you <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;assert.h&gt;</span></code>,
an <code class="docutils literal notranslate"><span class="pre">assert</span></code> “macro” becomes available which can be used to
declare known properties at certain points in your code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span><span class="p">(</span><span class="n">some_variable</span> <span class="o">==</span> <span class="n">some_value</span><span class="p">);</span>
</pre></div>
</div>
<p>Any boolean expression may be used as the argument to <code class="docutils literal notranslate"><span class="pre">assert</span></code>.
When compiling using <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-O3</span></code>, all <code class="docutils literal notranslate"><span class="pre">assert</span></code> expressions are
slided from the code.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table" id="id3">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">C0 versus C - basic language features</span><a class="headerlink" href="#id3" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>In C0</strong></p></th>
<th class="head"><p><strong>In C</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Statement structure</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;statement&gt;;</span></code></p></td>
<td><p>Same - i.e. terminated by a semi-colon.</p></td>
</tr>
<tr class="row-odd"><td><p>Scope delimiters</p></td>
<td><p>A pair of braces – i.e. <code class="docutils literal notranslate"><span class="pre">{&lt;code&gt;}</span></code></p></td>
<td><p>Same</p></td>
</tr>
<tr class="row-even"><td><p>Number types</p></td>
<td><p>Only 32-bit signed integers - <code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>Many sized integers both signed and unsigned.
Ex: <code class="docutils literal notranslate"><span class="pre">int</span></code> (signed “word”-sized integer)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">int8_t</span> <span class="o">/</span> <span class="n">uint8_t</span>
<span class="n">int16_t</span> <span class="o">/</span> <span class="n">uint16_t</span>
<span class="n">int32_t</span> <span class="o">/</span> <span class="n">uint32_t</span>
<span class="n">int64_t</span> <span class="o">/</span> <span class="n">uint64_t</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Floating point numbers</p></td>
<td><p>Not supported</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code> (32-bit) and <code class="docutils literal notranslate"><span class="pre">double</span></code> (64-bit)
types are available.</p></td>
</tr>
<tr class="row-even"><td><p>Character type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Boolean type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>You need to <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdbool.h&gt;</span></code> and then
you can use <code class="docutils literal notranslate"><span class="pre">bool</span></code> along with <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>Get address of a variable</p></td>
<td><p>Not allowed. You can only get pointers using <code class="docutils literal notranslate"><span class="pre">alloc</span></code>.</p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, then <code class="docutils literal notranslate"><span class="pre">&amp;x</span></code>
gives its address and is an expression of type <code class="docutils literal notranslate"><span class="pre">T*</span></code> –
i.e. a pointer to <code class="docutils literal notranslate"><span class="pre">T</span></code>. <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> can also be used on
members of <code class="docutils literal notranslate"><span class="pre">struct</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Pair</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">Pair</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">p1</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">p1</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

<span class="nb">int</span> <span class="o">*</span><span class="n">yptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">yptr</span><span class="p">);</span> <span class="o">//</span> <span class="n">Prints</span> <span class="mi">23</span>
</pre></div>
</div>
<p>In general, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> can be used on any expression that is valid on
the LHS of an assignment statement and will yield a pointer to
the memory location that is the target of that assignment. The
technical term for such an expression that can be used on the LHS
is, unsurprisingly, “l-value”.</p>
</td>
</tr>
<tr class="row-odd"><td><p>Get contents of a pointer</p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> is of type <code class="docutils literal notranslate"><span class="pre">T*</span></code>, then its contents are obtained
using <code class="docutils literal notranslate"><span class="pre">*p</span></code>.</p></td>
<td><p>Same as C0.</p></td>
</tr>
<tr class="row-even"><td><p>Treat boolean as integer</p></td>
<td><p>Not allowed</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(int)b</span></code> where <code class="docutils literal notranslate"><span class="pre">b</span></code> is declared as <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">b;</span></code>
A “boolean” value in C is equivalent to an integer
that is 0 to represent falsehood and 1 to represent
truth. So <code class="docutils literal notranslate"><span class="pre">printf(&quot;%d\n&quot;,</span> <span class="pre">b)</span></code> will print either
0 or 1 where <code class="docutils literal notranslate"><span class="pre">b</span></code> is a <code class="docutils literal notranslate"><span class="pre">bool</span></code> value.</p></td>
</tr>
<tr class="row-odd"><td><p>String type</p></td>
<td><p>Native type <code class="docutils literal notranslate"><span class="pre">string</span></code></p></td>
<td><p>Modeled as “pointer to character” (<code class="docutils literal notranslate"><span class="pre">char*</span></code>) with
the end of string signified by a character with numeric code <code class="docutils literal notranslate"><span class="pre">0</span></code>
called the “null character”, notated as <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>. When the C
compiler sees a string constant notated as <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code>,
it automatically inserts the null character at the end,
so the storage used for <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> is actually 6 bytes
and not 5 bytes.</p></td>
</tr>
<tr class="row-even"><td><p>Array type</p></td>
<td><p>Native type <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">[]</span></code> allocated using <code class="docutils literal notranslate"><span class="pre">alloc_array(T,</span> <span class="pre">n)</span></code>.</p></td>
<td><p>An array of <code class="docutils literal notranslate"><span class="pre">T</span></code> is essentially a pointer at which <code class="docutils literal notranslate"><span class="pre">n</span></code>
consecutive values of type <code class="docutils literal notranslate"><span class="pre">T</span></code> are stored. If <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*p</span></code>,
then you can access the <code class="docutils literal notranslate"><span class="pre">T</span></code> at index 4 using <code class="docutils literal notranslate"><span class="pre">p[4]</span></code>
or equivalently <code class="docutils literal notranslate"><span class="pre">*(p+4)</span></code>. C also has an array syntax
<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">arr[10];</span></code> that can be used for temporary “stack”
allocation and for sequences stored in <code class="docutils literal notranslate"><span class="pre">struct``s.</span> <span class="pre">Such</span>
<span class="pre">a</span> <span class="pre">variable</span> <span class="pre">``arr</span></code> is effectively a pointer though.
This adds more confusion at this stage, so we’ll not be
using C style arrays and will stick to pointer-based approach.</p></td>
</tr>
<tr class="row-odd"><td><p>Print things</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">printint</span></code> or <code class="docutils literal notranslate"><span class="pre">print</span></code> as appropriate.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdio.h&gt;</span></code> provides “formatted print”
<code class="docutils literal notranslate"><span class="pre">printf(&lt;format-string&gt;,</span> <span class="pre">&lt;additional-values&gt;)</span></code>.
So for example <code class="docutils literal notranslate"><span class="pre">printf(&quot;%d+%d=%d\n&quot;,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">5);</span></code>
will print “2+3=5”. See documentation of <code class="docutils literal notranslate"><span class="pre">printf</span></code>
for more details about format codes. <code class="docutils literal notranslate"><span class="pre">printf</span></code> will
automatically flush the output when it prints a new-line
character <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>Define type names</p></td>
<td><p>Ex: <code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span> <span class="pre">Node</span> <span class="pre">*node_t;</span></code></p></td>
<td><p>Same</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table" id="id4">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">C0 versus C - memory management</span><a class="headerlink" href="#id4" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Task</strong></p></th>
<th class="head"><p><strong>In C0</strong></p></th>
<th class="head"><p><strong>In C</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Allocate memory for a type <code class="docutils literal notranslate"><span class="pre">T</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*x</span> <span class="pre">=</span> <span class="pre">alloc(T);</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*x</span> <span class="pre">=</span> <span class="pre">(T*)malloc(sizeof(T));</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Allocate memory for an array of <code class="docutils literal notranslate"><span class="pre">N</span></code> elements of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">[]x</span> <span class="pre">=</span> <span class="pre">alloc_array(T,</span> <span class="pre">N);</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*x</span> <span class="pre">=</span> <span class="pre">(T*)malloc(N</span> <span class="pre">*</span> <span class="pre">sizeof(T));</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Free allocated memory.</p></td>
<td><p>Not needed since garbage collector takes care of it.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">free(x)</span></code> where x stores a pointer returned by <code class="docutils literal notranslate"><span class="pre">malloc</span></code>.
Not freeing allocated memory in C results in a “memory leak”.</p></td>
</tr>
<tr class="row-odd"><td><p>Casting</p></td>
<td><p>Restricted scenarios in C1 language extension</p></td>
<td><ol class="arabic simple">
<li><p>Free casting between pointer types using <code class="docutils literal notranslate"><span class="pre">(T2*)v</span></code> where
<code class="docutils literal notranslate"><span class="pre">v</span></code> is of type <code class="docutils literal notranslate"><span class="pre">T1*</span></code>.</p></li>
<li><p>Free casting between structure types is an error.</p></li>
<li><p>Free casting between <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">char</span></code>
since all three are integers under the hood. The compiler
may warn when you cast a “larger type” to a “smaller type” –
ex: from <code class="docutils literal notranslate"><span class="pre">int</span></code> to <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>Treat character as integer</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">char_ord(char</span> <span class="pre">ch)</span></code> function in <code class="docutils literal notranslate"><span class="pre">string</span></code> library.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(int)ch</span></code> where <code class="docutils literal notranslate"><span class="pre">ch</span></code> is a <code class="docutils literal notranslate"><span class="pre">char</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>Treat integer as character</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">char_chr(int</span> <span class="pre">i)</span></code> function in <code class="docutils literal notranslate"><span class="pre">string</span></code> library.</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(char)i</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is an integer type.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="pst-scrollable-table-container"><table class="table" id="id5">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">C0 versus C - iteration</span><a class="headerlink" href="#id5" title="Link to this table">#</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 40.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>In C0</strong></p></th>
<th class="head"><p><strong>In C</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>For loops</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(&lt;init&gt;;&lt;cond&gt;;&lt;step&gt;)</span> <span class="pre">{</span> <span class="pre">&lt;body&gt;</span> <span class="pre">}</span></code></p></td>
<td><p>Same</p></td>
</tr>
<tr class="row-odd"><td><p>While loops</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(&lt;cond&gt;)</span> <span class="pre">{</span> <span class="pre">&lt;body&gt;</span> <span class="pre">}</span></code></p></td>
<td><p>Same</p></td>
</tr>
<tr class="row-even"><td><p>Break out of <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> loops</p></td>
<td><p>Not supported</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">break;</span></code> statement</p></td>
</tr>
<tr class="row-odd"><td><p>Jump back to loop condition ignoring rest of loop body.</p></td>
<td><p>Not supported</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">continue;</span></code> statement</p></td>
</tr>
<tr class="row-even"><td><p>Returning from a function</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">&lt;expr&gt;;</span></code></p></td>
<td><p>Same</p></td>
</tr>
<tr class="row-odd"><td><p>Functions</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&lt;return-type&gt;</span> <span class="pre">&lt;fn-name&gt;(&lt;arg1-type&gt;</span> <span class="pre">&lt;var1&gt;,</span> <span class="pre">...)</span> <span class="pre">{</span> <span class="pre">&lt;body&gt;</span> <span class="pre">}</span></code></p></td>
<td><p>Same</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="casting">
<h2>Casting<a class="headerlink" href="#casting" title="Link to this heading">#</a></h2>
<p>Casting is about treating a value of one type as a value of another type.
The syntax for that in C is -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">one_type</span><span class="w"> </span><span class="n">val1</span><span class="p">;</span>
<span class="n">another_type</span><span class="w"> </span><span class="n">val2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">another_type</span><span class="p">)</span><span class="n">val1</span><span class="p">;</span>
</pre></div>
</div>
<p>i.e. You place the type you want to treat <code class="docutils literal notranslate"><span class="pre">val1</span></code> as within parentheses preceding the
value of interest. A common need is to cast between various numeric types, <code class="docutils literal notranslate"><span class="pre">int</span></code>
to <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> to <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> and so on.</p>
<p>“Downcasting” is the term used to refer to a casting operation from a “larger” type
to a “smaller” type. For example, since <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> is 4-bytes in size, casting a
<code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> value to <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> which is only one byte would be a “downcasting”.
Downcasting usually results in loss of information unless you know by some other
means that there won’t be information loss. For example, you may have a <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>
value that you know is in the range <span class="math notranslate nohighlight">\([0,255]\)</span> and therefore that it is safe
to cast it down to <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code>. The compiler won’t be able to validate that for you
in general and will at most warn you about potential information loss.</p>
<p>Another commonly used casting operation in C is between pointer types, known as
a “reinterpret cast”. The syntax is the same, except that two types are both
pointer types. While C may not permit you to cast from a <code class="docutils literal notranslate"><span class="pre">float</span></code> to a particular
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Something</span></code>, C permits you to cast between <strong>any</strong> two pointer types.</p>
<p>For example -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span><span class="c1"> // For uint8_t and such</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">878265</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;v = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="c1">// vptr points to an int, which is stored ass 4 consecutive bytes,</span>
<span class="w">                    </span><span class="c1">// (depending on CPU type) in least-significant-byte-first order.</span>

<span class="w">    </span><span class="c1">// We&#39;re now looking at the bytes that make up the integer.</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">vbytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">vptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;vbytes = &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// We now compute the integer back from the individual bytes and check it.</span>
<span class="w">    </span><span class="c1">// Note that the order of the bytes is machine dependent. So this program</span>
<span class="w">    </span><span class="c1">// will print out whether it uses &quot;little endian&quot; or &quot;big endian&quot; ordering.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">computed1_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">computed2_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">vbytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">computed1_v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;computed_v = %d and your computer is &#39;little endian&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">computed1_v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">computed2_v</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;computed_v = %d and your computer is &#39;big endian&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">computed2_v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;little_endian_v = %d, big_endian_v = %d and I don&#39;t know what went wrong.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">               </span><span class="n">computed1_v</span><span class="p">,</span><span class="w"> </span><span class="n">computed2_v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>C’s permission to cast between <strong>any</strong> two pointer types is a
double edged sword.  It can be used very effectively to implement various
abstractions (example <code class="docutils literal notranslate"><span class="pre">qsort</span></code> discussed in the next section) including
what was the origins of “object oriented programming”. It also comes with
the danger of crashing your system if you don’t really know what you’re
doing. For example, casting a <code class="docutils literal notranslate"><span class="pre">float</span></code> to an <code class="docutils literal notranslate"><span class="pre">int</span></code> will get you a
truncating behaviour. However, if you cast a <code class="docutils literal notranslate"><span class="pre">float*</span></code> to an <code class="docutils literal notranslate"><span class="pre">int*</span></code> since
both are 4-bytes in size, there is no information loss, but the integer
value won’t make any sense unless your intention is to work with the
bit-representation of floating point numbers for some reason.</p>
</div>
<p>The cast operation can also be “chained” like this - <code class="docutils literal notranslate"><span class="pre">(float)(int)(uint8_t)val</span></code>.</p>
</section>
<section id="function-pointers">
<h2>Function pointers<a class="headerlink" href="#function-pointers" title="Link to this heading">#</a></h2>
<p>You’re used to passing around functions in python as “first class values”.
They were called by various names, “lambda”, “closure” or just plain “function”.</p>
<p>Lower level languages like C eschew the complexity that comes with implementing
closures in favour of simpler primitives that you can build up from. While C
does not have the concept of “lambda” or “closure” <a class="footnote-reference brackets" href="#cblocks" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, it does permit
you to write code that can store and pass around stateless functions as values
as “function pointers”.</p>
<p>The underlying principle is that a function is just a block of code or machine
instructions itself residing in memory at a certain location. So if we have the
address of this location and know something about what the code residing there
will do if we jump to that location, then we can use that to add customizations
to behaviour of our code. This is, once more, the notion of “interface” coming
up of use.</p>
<p>A common kind of function pointer usage is to write custom comparison functions
for sorting algorithms. For example, the standard C <code class="docutils literal notranslate"><span class="pre">qsort</span></code> function has the
following signature -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nitems</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>
</pre></div>
</div>
<p>Let’s break that down.</p>
<ol class="arabic simple">
<li><p>We will want to be able to sort arrays of arbitrary items. The <code class="docutils literal notranslate"><span class="pre">base</span></code> argument
is used to provide a pointer to the first element of the array of items.</p></li>
<li><p>The sorting algorithm needs to know how many items and how big each item is
in order to be able to compare them, swap items at indices and such. The <code class="docutils literal notranslate"><span class="pre">nitems</span></code>
argument gives the length of the array and <code class="docutils literal notranslate"><span class="pre">size</span></code> gives how many bytes to
skip from one item to the next.</p></li>
<li><p>It also needs to know how to declare one item to be “less than” another
so that it can decide whether to swap them or not. This is the <code class="docutils literal notranslate"><span class="pre">compare</span></code>
argument.</p></li>
</ol>
<p>It does not need to know anything else about the structure of the array and its items,
and therefore the <code class="docutils literal notranslate"><span class="pre">qsort</span></code> function’s signature precisely declares only what it
needs.</p>
<p>What’s of interest here is the last <code class="docutils literal notranslate"><span class="pre">compare</span></code> argument.</p>
<p>It is common to provide comparison functions with the following contract -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">my_comparison_fn</span><span class="p">(</span><span class="n">thing_t</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">thing_t</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span>
<span class="c1">// Returns -1 if t1 is &quot;less than&quot; t2,</span>
<span class="c1">// Returns 1 if t1 is &quot;greater than&quot; t2,</span>
<span class="c1">// Returns 0 if t1 is &quot;equal to&quot; t2.</span>
</pre></div>
</div>
<p>We could have three functions to do that, but that will usually result in a lot
of duplicate code needing to be written between the three functions and this way
is more compact and sufficiently general. The reason for that redundancy is that
the contract it needs to follow is not merely about how it treats its input
and what set of values it returns. Such a comparison function must also meet some
additional criteria -</p>
<ol class="arabic simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">compare(v1,v2)</span> <span class="pre">==</span> <span class="pre">compare(v2,v3)</span></code>, then <code class="docutils literal notranslate"><span class="pre">compare(v1,v2)</span> <span class="pre">==</span> <span class="pre">compare(v1,v3)</span></code>
as well. This captures the transitive nature of comparisons -</p>
<ul class="simple">
<li><p>If a &lt; b and b &lt; c, then a &lt; c.</p></li>
<li><p>If a == b and b == c, then a == c.</p></li>
<li><p>If a &gt; b and b &gt; c, then a &gt; c.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">compare(v1,v2)</span> <span class="pre">+</span> <span class="pre">compare(v2,v1)</span> <span class="pre">==</span> <span class="pre">0</span></code>. This captures the reflexivity of
equality - i.e. a == b implies b == a. It also captures the relationship between
“less than” and “greater than” - i.e. a &lt; b implies b &gt; a.</p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">compare</span></code> argument to <code class="docutils literal notranslate"><span class="pre">qsort</span></code> also has the same structure as the
comparison function given above, except that the <code class="docutils literal notranslate"><span class="pre">thing_t</span></code> is a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span>
<span class="pre">*</span></code> since <code class="docutils literal notranslate"><span class="pre">qsort</span></code> doesn’t know anything about the type of values in the
array. The <code class="docutils literal notranslate"><span class="pre">const</span></code> here is used to signify that the comparison function will
not modify the contents of what it is comparing. That would be a disaster if
we were to permit it.</p>
<p>You can turn an ordinary C function signature into a type that represents
“functions like this” by simply wrapping the function name as <code class="docutils literal notranslate"><span class="pre">(*comparison_fn)</span></code>
and using it in a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">comparison_fn</span><span class="p">)(</span><span class="n">thing_t</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">thing_t</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span>
</pre></div>
</div>
<p>Once defined like that, the name <code class="docutils literal notranslate"><span class="pre">comparison_fn</span></code> will be a type that represents
“function that takes two <code class="docutils literal notranslate"><span class="pre">thing_t</span></code> values as arguments and returns an <code class="docutils literal notranslate"><span class="pre">int</span></code>”.
So for <code class="docutils literal notranslate"><span class="pre">qsort</span></code>, we could’ve split the declaration like this as well -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">qsort_comparator</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nitems</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">qsort_comparator</span><span class="w"> </span><span class="n">compare</span><span class="p">);</span>
</pre></div>
</div>
<p>… which is equivalent to the previous declaration but perhaps a little
more readable. If we have an array of <code class="docutils literal notranslate"><span class="pre">float</span></code> values and want to sort
based on, say, the <code class="docutils literal notranslate"><span class="pre">sin</span></code> of these values for some reason, we could do it
like this -</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">sin_compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">v1</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">v2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sf1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sf2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sf1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">sf2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Although equality of floats is not good to rely on.</span>
<span class="p">}</span>

<span class="kt">float</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="c1">// Fill up values array with some values.</span>

<span class="c1">// Sort them according to our ``sin_compare`` function.</span>
<span class="n">qsort</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sin_compare</span><span class="p">);</span>
</pre></div>
</div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">&amp;sin_compare</span></code> gives us the “function pointer” for the
<code class="docutils literal notranslate"><span class="pre">sin_compare</span></code> function. Since <code class="docutils literal notranslate"><span class="pre">sin_compare</span></code> has the exact same signature
as the <code class="docutils literal notranslate"><span class="pre">compare</span></code> argument of <code class="docutils literal notranslate"><span class="pre">qsort</span></code>, we can simply pass this pointer to
<code class="docutils literal notranslate"><span class="pre">qsort</span></code> and it will use it to determine the order within the array.</p>
<p>It is arguable that a more flexible way to provide such a sorting facility is
to include a “context” pointer that <code class="docutils literal notranslate"><span class="pre">qsort</span></code> can make available to the comparison
function. For example, we may have an array of indices into another array and we
may want to sort the array of indices based on some property of the corresponding
item in the other array. With the current implementation of qsort, you will be forced
to model your problem as an array of pointers first and then convert back to indices.
However, if we include a context pointer that can be passed around, that lets us
model the problem whatever way we want to and write an appropriate comparison
function. Indeed, the <code class="docutils literal notranslate"><span class="pre">qsort_s</span></code> function provides exactly that.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">qsort_s</span><span class="p">(</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">items</span><span class="p">,</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">),</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span>
<span class="w">    </span><span class="p">);</span>
</pre></div>
</div>
<p>The expectation is that the context pointer you pass to <code class="docutils literal notranslate"><span class="pre">qsort</span></code> will be
passed to every call to the compare function so that additional information it
needs to decide the comparison can be made available through it.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="cblocks" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Although Apple added a notion of “blocks” to C which are closures
<a class="reference external" href="https://en.wikipedia.org/wiki/Blocks_(C_language_extension">https://en.wikipedia.org/wiki/Blocks_(C_language_extension</a>).</p>
</aside>
</aside>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="lists.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Linked lists</p>
      </div>
    </a>
    <a class="right-next"
       href="dict.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Dictionaries and associated data structures</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-c-memory-model">The C memory model</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-c-stack">The C stack</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#differences-from-c0">Differences from C0</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#casting">Casting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-pointers">Function pointers</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Srikumar K. S.
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021, Srikumar K. S..
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>